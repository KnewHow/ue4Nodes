# Day08

## 1 Tick

### 1.1 定义

![image-20200513092616117](../images/image-20200513092616117.png)

每一帧都会被调用，其中 Delta Seconds 表示每帧间隔的时间，单位 seconds，这个时间会根据不同显卡的性能做出不同的改变。

Tick的时间会受到场景中子弹时间的影响。

设置物体的偏移：

![image-20200513093125567](../images/image-20200513093125567.png)



### 1.2 使用Tick实现物体的缓慢移动

![image-20200513093342571](../images/image-20200513093342571.png)



### 1.3 Tick的一些参数

![image-20200513094943493](../images/image-20200513094943493.png)



## 2 碰撞

### 2.1 Event Actor BeginOverlap 和 Event Actor EndOverlap (交叠)

开始重叠，不过需要设置物体可以被穿过：

![image-20200513101943488](../images/image-20200513101943488.png)



* 无碰撞 ![image-20200513100503990](../images/image-20200513100503990.png)

​     不会经过物理引擎

* 纯查询 ![image-20200513100543927](../images/image-20200513100543927.png)

会有overlap 事件

* ![image-20200513100617543](../images/image-20200513100617543.png)

纯物理信息，不会产生overlap。

蓝图演示：

![image-20200513102740784](../images/image-20200513102740784.png)

可以理解为：对可以穿透的物体添加了两个监听的事件，开始交叠(beginOverlap)和结束交叠(endOverlap)



### 2 碰到(Hit)



## 3 鼠标事件

### 3.1 Hover

![image-20200513103543269](../images/image-20200513103543269.png)

### 3.2 Touch

触控

![image-20200513103947477](../images/image-20200513103947477.png)



在设计 UI 的时候会详细讲。

## 4 项目实战

### 4.1 使用程序网格来创建一个模型(了解)

程序网格可以用程序来搭建一个模型

![image-20200513104218223](../images/image-20200513104218223.png)



### 4.2 用程序网格复制一个静态模型

![image-20200513105131885](../images/image-20200513105131885.png)

按 F8 可以脱离游戏控制，这样可以看游戏里面的各种数据。

为什么要使用静态网格呢，因为原来的静态模型无法切割，只能使用程序网格

### 4.3 实现一个切割的效果

#### 4.3.1 让模型运行 CPU 访问

![image-20200513111454246](../images/image-20200513111454246.png)

实现蓝图：

![image-20200513111850680](../images/image-20200513111850680.png)

补做:https://www.bilibili.com/video/BV1dJ411v7dR

## 5 输入

在进入 ue4中，模块可以使用 WASD以及鼠标，这就是输入。

### 5.1 Pawn 

新建Pawn

![image-20200513133949469](../images/image-20200513133949469.png)

### 5.2 GameMode

新建一个游戏模式

![image-20200513134102843](../images/image-20200513134102843.png)

绑定Pawn 到 GameMode

![image-20200513134239919](../images/image-20200513134239919.png)



### 5.3 切换游戏模式

![image-20200513134143466](../images/image-20200513134143466.png)



### 5.4 自定义输入

![image-20200513135125931](../images/image-20200513135125931.png)

#### 5.4.1 按键 W 移动

![image-20200513134538535](../images/image-20200513134538535.png)

#### 5.4.2 AnyKey 的用法

![image-20200513134726064](../images/image-20200513134726064.png)



![image-20200513134738281](../images/image-20200513134738281.png)



#### 5.4.3 鼠标的轴输入

![image-20200513135105734](../images/image-20200513135105734.png)



### 5.5 主动索取判断

#### 5.5.1 平移

![image-20200513140435346](../images/image-20200513140435346.png)

#### 5.5.2 旋转(Rotator)

推荐使用如下的操作：

![image-20200513142808399](../images/image-20200513142808399.png)



不要将 Rotator 拆解，然后各种相加，不然会出现各种各样的问题。

最终的效果蓝图：http://blueprintue.cn/blueprint/6zekku3v/

需要添加摄像机来演示：

![image-20200513144240617](../images/image-20200513144240617.png)



### 5.6 输入绑定

![image-20200513144610634](../images/image-20200513144610634.png)

scale的复数表示相反的方向。

![image-20200513145037819](../images/image-20200513145037819.png)



![image-20200513151540434](../images/image-20200513151540434.png)



![image-20200513151555002](../images/image-20200513151555002.png)



更简单的版本，将Forward和Back以及Right和Left合并，添加一个负号即可：

![image-20200513154450353](../images/image-20200513154450353.png)



### 5.7 输入控制

![image-20200513152338253](../images/image-20200513152338253.png)



### 5.8 鼠标事件



![image-20200513153112956](../images/image-20200513153112956.png)

显示鼠标：

![image-20200513153233029](../images/image-20200513153233029.png)

获取鼠标当前的位置：

![image-20200513153321639](../images/image-20200513153321639.png)

将当前鼠标的坐标转换为游戏世界的坐标和方向：

但是此时的坐标在摄像机表面，因此需要发射一条射线，沿着WorldDirection,并且指定长度，当碰撞到一个物体的时候，将物品放置在上面。

![image-20200513153830775](../images/image-20200513153830775.png)

## 6 射线检测-添加白球

![image-20200513171006249](../images/image-20200513171006249.png)



完整的蓝图：http://blueprintue.cn/blueprint/qioi6yzx/

## 7 BSP 画刷

ue4 建模工具。

## 8 ue4 小白人动作

![image-20200513161420183](../images/image-20200513161420183.png)