# Day11

## 1 Delay

在延迟中，无法退出游戏的。

### 1.1 Delay

在Delay状态中，新触发的delay 事件都会被拦截，不会接收新事件，知道当前事件完成。

![image-20200518100709147](../images/image-20200518100709147.png)

### 1.2 Retriggerable Delay

每次都以最新的触发事件开始，将之正在延迟的时间清零。

![image-20200518102209209](../images/image-20200518102209209.png)





演示实例：

![image-20200518102345626](../images/image-20200518102345626.png)



## 2 定时器和时间轴

### 2.1 时间轴

他是一个变量

![image-20200518103212833](../images/image-20200518103212833.png)

![image-20200518104405676](../images/image-20200518104405676.png)

曲线类别：

![image-20200518103927410](../images/image-20200518103927410.png)

曲线的分类：

![image-20200518103755551](../images/image-20200518103755551.png)

浮点和向量：

![image-20200518103851257](../images/image-20200518103851257.png)



### 2.2 定时器

![image-20200518104756612](../images/image-20200518104756612.png)



![image-20200518110250417](../images/image-20200518110250417.png)



## 3 退出游戏

![image-20200518110329164](../images/image-20200518110329164.png)



![image-20200518110443209](../images/image-20200518110443209.png)

## 4 保存游戏

在GameSave 中保存的对象是根据名字来保存的，如果存的时候，对象存在，但是载入的时候，对象不存在，则无法获取该对象(保存的是对象的名字)。



## 5 FlipFlop

![image-20200518112346940](../images/image-20200518112346940.png)

## 6 Do Once and Do N

![image-20200518112531135](../images/image-20200518112531135.png)

二者都可以通过 Reset 来重置。

## 7 随机数

![image-20200518133514359](../images/image-20200518133514359.png)

随机数的种子：

![image-20200518133836794](../images/image-20200518133836794.png)



## 8 UMG

### 8.1 创建 UMG

![image-20200518134809414](../images/image-20200518134809414.png)

![image-20200518134824290](../images/image-20200518134824290.png)



### 8.2 使用 UMG

创建并使用

![image-20200518140028451](../images/image-20200518140028451.png)

![image-20200518140112482](../images/image-20200518140112482.png)



UMG 初始的构造函数：

![image-20200518143326307](../images/image-20200518143326307.png)

### 8.3 各种控件

#### 8.3.1 Button

##### 8.3.1.1 按钮的样式调整

![image-20200518141008382](../images/image-20200518141008382.png)

##### 8.3.1.2 按钮一些事件

![image-20200518143138237](../images/image-20200518143138237.png)

##### 8.3.1.3 按钮事件的定义

![image-20200518143631077](../images/image-20200518143631077.png)

#### 8.3.2 CheckBox

##### 8.3.2.1 样式

![image-20200518143836971](../images/image-20200518143836971.png)

##### 8.3.2.2 事件

![image-20200518144033883](../images/image-20200518144033883.png)



#### 8.3.3 Image

![image-20200518153315026](../images/image-20200518153315026.png)

图片可以使用画刷(材质)

#### 8.3.4 Progress Bar

![image-20200518153203912](../images/image-20200518153203912.png)

进度绑定，将进度条绑定到一个函数：

![image-20200518162550960](../images/image-20200518162550960.png)

![image-20200518162611880](../images/image-20200518162611880.png)

#### 8.3.5 Slider

![image-20200518153809447](../images/image-20200518153809447.png)



将一个控制设置为变量：

![image-20200518154207952](../images/image-20200518154207952.png)

#### 8.3.6 Text

![image-20200518154318906](../images/image-20200518154318906.png)

修改字体：

![image-20200518155217295](../images/image-20200518155217295.png)

可以使用材质让字体飘逸起来。

### 8.4 在UMG 使用材质

#### 8.4.1 修改材质的 Domain

![image-20200518144546935](../images/image-20200518144546935.png)

#### 8.4.2 修改透明模式

![image-20200518145405011](../images/image-20200518145405011.png)



#### 8.4.3 在UMG 中使用 

![image-20200518145554563](../images/image-20200518145554563.png)



#### 8.4.5 UI材质中的混合模式(Blend Mode)

![image-20200518150502276](../images/image-20200518150502276.png)

我们有三种颜色，红色R:(1,0,0)，绿色G(0,1,0)，蓝色B(0,0,1),

![image-20200518151213432](../images/image-20200518151213432.png)

![image-20200518151231756](../images/image-20200518151231756.png)

![image-20200518151259332](../images/image-20200518151259332.png)

则在 Blend Mode 的 **additive** 模式下，上面三种颜色相交会出现如下的情况：

![image-20200518151645374](../images/image-20200518151645374.png)

中间的颜色为白色，原因是(1,0,0)+(0,1,0)+(0,0,1) = (1,1,1) = 白色

如果将混合模式(Blendmode)中的 additive 改成 **modulate**，则会出现如下效果：

![image-20200518152025047](../images/image-20200518152025047.png)

此时相交的部分会变成黑色，原因是因为：(1,0,0)`*`(0,1,0)`*`(0,0,1) = (0,0,0) = 黑色



混合模式的实战：将一个彩色的图片变成一张灰色的图片：

![image-20200518152711169](../images/image-20200518152711169.png)



### 8.5 UE4 字体

创建字体：

![image-20200518155122944](../images/image-20200518155122944.png)

引用其他字体

![image-20200518155032697](../images/image-20200518155032697.png)

### 8.6 多语言和国际化

在 UE4 中，所有显示的东西都需要使用`Text` 类型来完成，因为它可以进行多语言切换。在 UI 里面的Text，他存储的内容的类型就是`Text`。

![image-20200518175657271](../images/image-20200518175657271.png)

但是在中文界面，我们如何进行翻译呢？

首先我们打开本地化设置：

![image-20200518174351989](../images/image-20200518174351989.png)

 然后进行如下配置：

![image-20200518174810852](../images/image-20200518174810852.png)

扫描后点击OK:

![image-20200518174855228](../images/image-20200518174855228.png)

点击进行翻译：

![image-20200518174922160](../images/image-20200518174922160.png)



进行翻译：

![image-20200518174948077](../images/image-20200518174948077.png)

最后点击编译:

![image-20200518175145883](../images/image-20200518175145883.png)

最后要看效果，需要打包或者模拟运行：

![image-20200518175236604](../images/image-20200518175236604.png)

KnewHow-> 袁国浩

正常运行：

![image-20200518175533061](../images/image-20200518175533061.png)

模拟运行：

![image-20200518175307316](../images/image-20200518175307316.png)

模型的是根据操作系统的语言来计算的。